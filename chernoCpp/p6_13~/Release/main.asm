; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29112.0 

	TITLE	f:\c++vc\p6_13~\main.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_0CE@DNJNFGJO@?$DM?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DNPart13?3string?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ ; `string'
PUBLIC	??_C@_05DGFDNKII@Rabit@				; `string'
PUBLIC	??_C@_06IKCLLJCF@?5tank?$CB@			; `string'
PUBLIC	??_C@_02LCNFMBND@an@				; `string'
PUBLIC	??_C@_02BMCPJMB@sb@				; `string'
PUBLIC	??_C@_0L@GEBBCBBN@Rabit?$AAtank@		; `string'
PUBLIC	??_C@_1M@DDCHFMNC@?$AAR?$AAa?$AAb?$AAi?$AAt@	; `string'
PUBLIC	??_C@_2BI@LFNBNGBE@?$AA?$AA?$AAR?$AA?$AA?$AAa?$AA?$AA?$AAb?$AA?$AA?$AAi?$AA?$AA?$AAt@ ; `string'
PUBLIC	??_C@_04HCFFIKMN@tank@				; `string'
PUBLIC	??_C@_0BG@HCBNOMHN@Rabit?6Tank?6is?5?6pretty@	; `string'
PUBLIC	??_C@_0BJ@JMKONHGC@Rabit?6tank?6is?5wonderful?6@ ; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
EXTRN	__imp_?rdstate@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBE_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAE_J_J@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:PROC
EXTRN	__imp___invalid_parameter_noinfo_noreturn:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__imp____std_terminate:PROC
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__imp____std_exception_copy:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:PROC
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp____std_exception_destroy:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__imp____CxxFrameHandler3:PROC
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BJ@JMKONHGC@Rabit?6tank?6is?5wonderful?6@
CONST	SEGMENT
??_C@_0BJ@JMKONHGC@Rabit?6tank?6is?5wonderful?6@ DB 'Rabit', 0aH, 'tank', 0aH
	DB	'is wonderful', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HCBNOMHN@Rabit?6Tank?6is?5?6pretty@
CONST	SEGMENT
??_C@_0BG@HCBNOMHN@Rabit?6Tank?6is?5?6pretty@ DB 'Rabit', 0aH, 'Tank', 0aH
	DB	'is ', 0aH, 'pretty', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HCFFIKMN@tank@
CONST	SEGMENT
??_C@_04HCFFIKMN@tank@ DB 'tank', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_2BI@LFNBNGBE@?$AA?$AA?$AAR?$AA?$AA?$AAa?$AA?$AA?$AAb?$AA?$AA?$AAi?$AA?$AA?$AAt@
CONST	SEGMENT
??_C@_2BI@LFNBNGBE@?$AA?$AA?$AAR?$AA?$AA?$AAa?$AA?$AA?$AAb?$AA?$AA?$AAi?$AA?$AA?$AAt@ DB 'R'
	DB	00H, 00H, 00H, 'a', 00H, 00H, 00H, 'b', 00H, 00H, 00H, 'i', 00H
	DB	00H, 00H, 't', 00H, 00H, 00H, 00H, 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@DDCHFMNC@?$AAR?$AAa?$AAb?$AAi?$AAt@
CONST	SEGMENT
??_C@_1M@DDCHFMNC@?$AAR?$AAa?$AAb?$AAi?$AAt@ DB 'R', 00H, 'a', 00H, 'b', 00H
	DB	'i', 00H, 't', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GEBBCBBN@Rabit?$AAtank@
CONST	SEGMENT
??_C@_0L@GEBBCBBN@Rabit?$AAtank@ DB 'Rabit', 00H, 'tank', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02BMCPJMB@sb@
CONST	SEGMENT
??_C@_02BMCPJMB@sb@ DB 'sb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LCNFMBND@an@
CONST	SEGMENT
??_C@_02LCNFMBND@an@ DB 'an', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06IKCLLJCF@?5tank?$CB@
CONST	SEGMENT
??_C@_06IKCLLJCF@?5tank?$CB@ DB ' tank!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DGFDNKII@Rabit@
CONST	SEGMENT
??_C@_05DGFDNKII@Rabit@ DB 'Rabit', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@DNJNFGJO@?$DM?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DNPart13?3string?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
CONST	SEGMENT
??_C@_0CE@DNJNFGJO@?$DM?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DNPart13?3string?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ DB '<'
	DB	'==========Part13:string==========>', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$forward@ABQAD@std@@YAABQADABQAD@Z		; std::forward<char * const &>
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?compare@?$_Narrow_char_traits@DH@std@@SAHQBD0I@Z ; std::_Narrow_char_traits<char,int>::compare
PUBLIC	?find@?$_Narrow_char_traits@DH@std@@SAPBDQBDIABD@Z ; std::_Narrow_char_traits<char,int>::find
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Get_size_of_n@$00@std@@YAII@Z		; std::_Get_size_of_n<1>
PUBLIC	??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
PUBLIC	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::move<std::allocator<char> &>
PUBLIC	??$_Traits_find@U?$char_traits@D@std@@@std@@YAIQBDII0I@Z ; std::_Traits_find<std::char_traits<char> >
PUBLIC	??$min@I@std@@YAABIABI0@Z			; std::min<unsigned int>
PUBLIC	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::move
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?deallocate@?$allocator@D@std@@QAEXQADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??$max@I@std@@YAABIABI0@Z			; std::max<unsigned int>
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z	; std::_Narrow_char_traits<char,int>::length
PUBLIC	?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::copy
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
PUBLIC	??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBEXQADIQBD@Z ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator()
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
PUBLIC	_main
PUBLIC	?PrintString@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; PrintString
PUBLIC	??__Ks@string_literals@literals@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@PBDI@Z ; std::literals::string_literals::operator "" s
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	??$_Convert_size@I@std@@YAII@Z			; std::_Convert_size<unsigned int>
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?max@?$numeric_limits@H@std@@SAHXZ		; std::numeric_limits<int>::max
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AAE@QBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	??2@YAPAXIPAX@Z					; operator new
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___std_terminate:PROC
EXTRN	_memchr:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$_main DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$_main
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$_main DD 0ffffffffH
	DD	FLAT:__unwindfunclet$_main$0
	DD	00H
	DD	FLAT:__unwindfunclet$_main$1
	DD	00H
	DD	FLAT:__unwindfunclet$_main$2
	DD	02H
	DD	FLAT:__unwindfunclet$_main$3
	DD	00H
	DD	FLAT:__unwindfunclet$_main$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DQ 00000000119930522r ; 2.33398e-314
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000500000000r		; 1.061e-313
__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DQ 00000000119930522r ; 2.33398e-314
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DQ 00000000019930522r ; 2.11987e-315
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DQ 00000000619930522r ; 1.2944e-313
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DQ	00000000000000001r		; 4.94066e-324
	DQ	00000000000000001r		; 4.94066e-324
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	04H
	DD	FLAT:___std_terminate
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DQ 00000000200000002r ; 4.24399e-314
	DQ	00000000100000003r		; 2.122e-314
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$6
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$6 DQ 00000000000000040r ; 3.16202e-322
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z DQ 00000000619930522r ; 1.2944e-313
	DD	FLAT:__unwindtable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$2
	DQ	00000000000000001r		; 4.94066e-324
	DQ	00000000000000001r		; 4.94066e-324
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	04H
	DD	FLAT:___std_terminate
__tryblocktable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z DQ 00000000200000002r ; 4.24399e-314
	DQ	00000000100000003r		; 2.122e-314
	DD	FLAT:__catchsym$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$6
__catchsym$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$6 DQ 00000000000000040r ; 3.16202e-322
	DD	00H
	DD	FLAT:__catch$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$0
xdata$x	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z PROC ; std::_Container_base0::_Alloc_proxy, COMDAT
; _this$dead$ = ecx

; 1067 :     void _Alloc_proxy(const _Fake_allocator&) noexcept {}

	ret	4
?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ENDP ; std::_Container_base0::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??__Ks@string_literals@literals@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@PBDI@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$ = -4				; size = 4
___$ReturnUdt$ = -4					; size = 4
__Len$dead$ = 8						; size = 4
??__Ks@string_literals@literals@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@PBDI@Z PROC ; std::literals::string_literals::operator "" s, COMDAT
; ___$ReturnUdt$ = ecx
; __Str$dead$ = edx

; 4648 :         _NODISCARD inline string operator"" s(const char* _Str, size_t _Len) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 2321 :         assign(_Ptr, _Count);

	push	5

; 4648 :         _NODISCARD inline string operator"" s(const char* _Str, size_t _Len) {

	mov	DWORD PTR ___$ReturnUdt$[ebp], esi

; 2321 :         assign(_Ptr, _Count);

	push	OFFSET ??_C@_05DGFDNKII@Rabit@

; 4293 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 4648 :         _NODISCARD inline string operator"" s(const char* _Str, size_t _Len) {

	mov	DWORD PTR ___$ReturnUdt$GSCopy$[ebp], esi

; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [esi], 0

; 2321 :         assign(_Ptr, _Count);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 4649 :             return string(_Str, _Len);

	mov	eax, esi
	pop	esi

; 4650 :         }

	mov	esp, ebp
	pop	ebp
	ret	0
??__Ks@string_literals@literals@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@PBDI@Z ENDP ; std::literals::string_literals::operator "" s
_TEXT	ENDS
; Function compile flags: /Ogtp
; File F:\C++VC\p6_13~\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File F:\C++VC\p6_13~\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File F:\C++VC\p6_13~\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File F:\C++VC\p6_13~\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File F:\C++VC\p6_13~\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File F:\C++VC\p6_13~\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File F:\C++VC\p6_13~\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File F:\C++VC\p6_13~\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File F:\C++VC\p6_13~\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File F:\C++VC\p6_13~\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File F:\C++VC\p6_13~\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File F:\C++VC\p6_13~\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File F:\C++VC\p6_13~\main.cpp
;	COMDAT _main
_TEXT	SEGMENT
_name4$ = -112						; size = 11
$T33 = -100						; size = 1
$T11 = -100						; size = 1
$T26 = -96						; size = 24
$T18 = -96						; size = 24
_namestring$ = -72					; size = 24
_stringname$ = -48					; size = 24
_name2$ = -24						; size = 5
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_main	PROC						; COMDAT

; 14   : int main() {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$_main
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 15   : 	std::cout << "<==========Part13:string==========>" << std::endl;

	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	mov	edx, OFFSET ??_C@_0CE@DNJNFGJO@?$DM?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DNPart13?3string?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 16   : 	const char* name = "Rabit";
; 17   : 	//"Rabit"存储在内存的const只读部分,即是能够不加const使用char*,你仍然难以改变它
; 18   : 	//name[2]='c';不要这么做,这没用,甚至会出错
; 19   : 	char namearray[] = "Rabit";
; 20   : 	namearray[2] = 'c';//数组是可以的
; 21   : 
; 22   : 	char name2[5] = { 'R','a','b','i','t' };
; 23   : 	char name3[6] = { 'R','a','b','i','t' };//"Rabit"多加一个\0终止符,占6字节
; 24   : 	//const char* 是c风格的字符串
; 25   : 	//const 在C11以前并不必要,但是一般不会改动字符串所以会加上
; 26   : 	//c11后, 字符串格式固定为 const char*(和编译器有关)
; 27   : 	//字符串内存固定,无法扩展
; 28   : 	//"Rabit"并未使用new ,仍在栈上,不需要也不能用delete[]
; 29   : 	std::cout << name << std::endl;

	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	mov	edx, OFFSET ??_C@_05DGFDNKII@Rabit@
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	DWORD PTR _name2$[ebp], 1768055122	; 69626152H
	mov	BYTE PTR _name2$[ebp+4], 116		; 00000074H
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 30   : 	std::cout << name2 << std::endl;//烫烫烫是内存守卫cc

	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	lea	edx, DWORD PTR _name2$[ebp]
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2984 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	push	5
	push	OFFSET ??_C@_05DGFDNKII@Rabit@
	lea	ecx, DWORD PTR _stringname$[ebp]

; 4293 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR _stringname$[ebp+16], 0

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR _stringname$[ebp+20], 15	; 0000000fH

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR _stringname$[ebp], 0

; 2984 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File F:\C++VC\p6_13~\main.cpp

; 35   : 	std::string stringname = "Rabit";//左边是string,右边是const char*

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2144 :         const value_type* _Result = _Bx._Buf;

	lea	edx, DWORD PTR _stringname$[ebp]

; 2145 :         if (_Large_string_engaged()) {

	cmp	DWORD PTR _stringname$[ebp+20], 16	; 00000010H

; 4642 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A

; 2145 :         if (_Large_string_engaged()) {

	cmovae	edx, DWORD PTR _stringname$[ebp]
; File F:\C++VC\p6_13~\main.cpp

; 36   : 	std::cout << stringname << std::endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4642 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

	push	DWORD PTR _stringname$[ebp+16]
	call	??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
	add	esp, 4
; File F:\C++VC\p6_13~\main.cpp

; 36   : 	std::cout << stringname << std::endl;

	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2859 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	edx, DWORD PTR _stringname$[ebp+20]
	mov	eax, edx
	mov	ecx, DWORD PTR _stringname$[ebp+16]
	sub	eax, ecx

; 2860 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	push	6
	push	OFFSET ??_C@_06IKCLLJCF@?5tank?$CB@
	cmp	eax, 6
	jb	SHORT $LN35@main

; 2136 :         if (_Large_string_engaged()) {

	cmp	edx, 16					; 00000010H
	lea	esi, DWORD PTR _stringname$[ebp]

; 2861 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [ecx+6]

; 2136 :         if (_Large_string_engaged()) {

	cmovae	esi, DWORD PTR _stringname$[ebp]

; 2863 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	add	esi, ecx
	mov	DWORD PTR _stringname$[ebp+16], eax

; 363  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 2864 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [esi+6], 0

; 2865 :             return *this;

	jmp	SHORT $LN34@main
$LN35@main:

; 2866 :         }
; 2867 : 
; 2868 :         return _Reallocate_grow_by(

	mov	BYTE PTR $T11[ebp], 0
	lea	ecx, DWORD PTR _stringname$[ebp]
	push	DWORD PTR $T11[ebp]
	push	6
	call	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN34@main:

; 2145 :         if (_Large_string_engaged()) {

	cmp	DWORD PTR _stringname$[ebp+20], 16	; 00000010H
	lea	ecx, DWORD PTR _stringname$[ebp]

; 533  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

	mov	eax, DWORD PTR _stringname$[ebp+16]

; 2145 :         if (_Large_string_engaged()) {

	cmovae	ecx, DWORD PTR _stringname$[ebp]

; 533  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

	cmp	eax, 2
	jb	SHORT $LN245@main

; 534  :         // xpos cannot exist, report failure
; 535  :         // N4659 24.3.2.7.2 [string.find]/1 says:
; 536  :         // 1. _Start_at <= xpos
; 537  :         // 2. xpos + _Needle_size <= _Hay_size;
; 538  :         // therefore:
; 539  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 540  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 541  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 542  :         return static_cast<size_t>(-1);
; 543  :     }
; 544  : 
; 545  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible
; 546  :         return _Start_at;
; 547  :     }
; 548  : 
; 549  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

	lea	esi, DWORD PTR [eax+ecx]

; 550  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {
; 551  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

	lea	eax, DWORD PTR [esi-1]
	sub	eax, ecx

; 356  :         return static_cast<const _Elem*>(_CSTD memchr(_First, _Ch, _Count));

	push	eax
	push	97					; 00000061H
	push	ecx
	call	_memchr
	mov	edx, eax
	add	esp, 12					; 0000000cH

; 552  :         if (!_Match_try) { // didn't find first character; report failure

	test	edx, edx
	je	SHORT $LN245@main
	npad	1
$LL56@main:

; 301  :         return _CSTD memcmp(_First1, _First2, _Count);

	movzx	ecx, BYTE PTR [edx]
	cmp	cl, 97					; 00000061H
	jne	SHORT $LN251@main
	movzx	eax, BYTE PTR [edx+1]
	cmp	al, 110					; 0000006eH
	jne	SHORT $LN251@main
	xor	eax, eax
	jmp	SHORT $LN252@main
$LN251@main:
	sbb	eax, eax
	or	eax, 1
$LN252@main:

; 556  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match

	test	eax, eax
	je	SHORT $LN245@main

; 550  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {
; 551  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

	inc	edx
	lea	eax, DWORD PTR [esi-1]
	sub	eax, edx

; 356  :         return static_cast<const _Elem*>(_CSTD memchr(_First, _Ch, _Count));

	push	eax
	push	97					; 00000061H
	push	edx
	call	_memchr
	mov	edx, eax
	add	esp, 12					; 0000000cH

; 552  :         if (!_Match_try) { // didn't find first character; report failure

	test	edx, edx
	jne	SHORT $LL56@main
$LN245@main:

; 2984 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	push	2
	push	OFFSET ??_C@_02BMCPJMB@sb@
	lea	ecx, DWORD PTR $T18[ebp]

; 4293 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR $T18[ebp+16], 0

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR $T18[ebp+20], 15		; 0000000fH

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T18[ebp], 0

; 2984 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File F:\C++VC\p6_13~\main.cpp

; 49   : 	PrintString("sb");

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2144 :         const value_type* _Result = _Bx._Buf;

	lea	edx, DWORD PTR $T18[ebp]

; 2145 :         if (_Large_string_engaged()) {

	cmp	DWORD PTR $T18[ebp+20], 16		; 00000010H

; 4642 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A

; 2145 :         if (_Large_string_engaged()) {

	cmovae	edx, DWORD PTR $T18[ebp]
; File F:\C++VC\p6_13~\main.cpp

; 8    : 	std::cout << string << std::endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4642 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

	push	DWORD PTR $T18[ebp+16]
	call	??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
	add	esp, 4
; File F:\C++VC\p6_13~\main.cpp

; 8    : 	std::cout << string << std::endl;

	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 49   : 	PrintString("sb");

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

	mov	edx, DWORD PTR $T18[ebp+20]
	cmp	edx, 16					; 00000010H
	jb	SHORT $LN102@main
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T18[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN112@main

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN112@main
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN112@main:

; 221  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN102@main:
; File F:\C++VC\p6_13~\main.cpp

; 52   : 	std::cout << "<==========Part13:string==========>" << std::endl;

	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	mov	edx, OFFSET ??_C@_0CE@DNJNFGJO@?$DM?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DNPart13?3string?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 53   : 	//中断
; 54   : 	const char name4[11] = u8"Rabit\0tank";

	mov	ax, WORD PTR ??_C@_0L@GEBBCBBN@Rabit?$AAtank@+8

; 55   : 	//u8没什么意思,和普通字符串一样-utf8
; 56   : 	std::cout << strlen(name4) << std::endl;

	lea	ecx, DWORD PTR _name4$[ebp]
	movq	xmm0, QWORD PTR ??_C@_0L@GEBBCBBN@Rabit?$AAtank@
	lea	edx, DWORD PTR [ecx+1]
	mov	WORD PTR _name4$[ebp+8], ax
	mov	al, BYTE PTR ??_C@_0L@GEBBCBBN@Rabit?$AAtank@+10
	movq	QWORD PTR _name4$[ebp], xmm0
	mov	BYTE PTR _name4$[ebp+10], al
	npad	1
$LL253@main:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL253@main
	sub	ecx, edx
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	ecx
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2321 :         assign(_Ptr, _Count);

	push	5
	push	OFFSET ??_C@_05DGFDNKII@Rabit@
	lea	ecx, DWORD PTR $T26[ebp]

; 4293 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR $T26[ebp+16], 0

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR $T26[ebp+20], 15		; 0000000fH

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T26[ebp], 0

; 2321 :         assign(_Ptr, _Count);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File F:\C++VC\p6_13~\main.cpp

; 68   : 	std::string namestring = "Rabit"s + "tank";

	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2859 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	edx, DWORD PTR $T26[ebp+20]
	mov	eax, edx
	mov	ecx, DWORD PTR $T26[ebp+16]
	sub	eax, ecx

; 2860 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	eax, 4
	jb	SHORT $LN139@main

; 2861 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [ecx+4]

; 2136 :         if (_Large_string_engaged()) {

	cmp	edx, 16					; 00000010H

; 2861 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	DWORD PTR $T26[ebp+16], eax

; 2135 :         value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR $T26[ebp]

; 2136 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR $T26[ebp]

; 363  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	mov	DWORD PTR [eax+ecx], 1802396020		; 6b6e6174H

; 2864 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [eax+ecx+4], 0

; 2865 :             return *this;

	lea	eax, DWORD PTR $T26[ebp]
	jmp	SHORT $LN138@main
$LN139@main:

; 2866 :         }
; 2867 : 
; 2868 :         return _Reallocate_grow_by(

	push	4
	push	OFFSET ??_C@_04HCFFIKMN@tank@
	mov	BYTE PTR $T33[ebp], 0
	lea	ecx, DWORD PTR $T26[ebp]
	push	DWORD PTR $T33[ebp]
	push	4
	call	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN138@main:

; 2606 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR _namestring$[ebp], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR _namestring$[ebp+16], xmm0

; 4293 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [eax], 0
; File F:\C++VC\p6_13~\main.cpp

; 68   : 	std::string namestring = "Rabit"s + "tank";

	mov	BYTE PTR __$EHRec$[ebp+8], 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2153 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR $T26[ebp+20]
	cmp	edx, 16					; 00000010H

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN173@main
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T26[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN183@main

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN183@main
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN183@main:

; 221  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN173@main:
; File F:\C++VC\p6_13~\main.cpp

; 79   : 	std::cout << nameR << nameRex << std::endl;

	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	mov	edx, OFFSET ??_C@_0BG@HCBNOMHN@Rabit?6Tank?6is?5?6pretty@
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4308 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR $T26[ebp+16], 0

; 4309 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR $T26[ebp+20], 15		; 0000000fH

; 4310 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4311 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T26[ebp], 0
; File F:\C++VC\p6_13~\main.cpp

; 79   : 	std::cout << nameR << nameRex << std::endl;

	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	edx, OFFSET ??_C@_0BJ@JMKONHGC@Rabit?6tank?6is?5wonderful?6@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2153 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR _namestring$[ebp+20]
	cmp	edx, 16					; 00000010H

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN200@main
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR _namestring$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN210@main

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN234@main
$LN210@main:

; 221  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN200@main:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2153 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR _stringname$[ebp+20]
	cmp	edx, 16					; 00000010H

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN227@main
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR _stringname$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN237@main

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN237@main
$LN234@main:
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN237@main:

; 221  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN227@main:
; File F:\C++VC\p6_13~\main.cpp

; 81   : }

	xor	eax, eax
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN256@main:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_main$0:
	lea	ecx, DWORD PTR _stringname$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_main$1:
	lea	ecx, DWORD PTR $T18[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_main$2:
	lea	ecx, DWORD PTR $T26[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_main$3:
	lea	ecx, DWORD PTR _namestring$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$_main:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-108]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$_main
	jmp	___CxxFrameHandler3
text$x	ENDS
_main	ENDP
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
$T5 = 8							; size = 1
__Ptr$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2879 :     basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

	push	ebp
	mov	ebp, esp

; 321  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	mov	edx, DWORD PTR __Ptr$[ebp]

; 2879 :     basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

	push	ebx
	push	esi
	push	edi

; 321  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	mov	edi, edx

; 2879 :     basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

	mov	ebx, ecx

; 321  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	lea	ecx, DWORD PTR [edi+1]
$LL15@append:
	mov	al, BYTE PTR [edi]
	inc	edi
	test	al, al
	jne	SHORT $LL15@append

; 2860 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	esi, DWORD PTR [ebx+20]

; 321  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	sub	edi, ecx

; 2859 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	ecx, DWORD PTR [ebx+16]

; 2860 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	eax, esi
	sub	eax, ecx
	cmp	edi, eax
	ja	SHORT $LN6@append

; 2861 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [ecx+edi]
	mov	DWORD PTR [ebx+16], eax

; 2135 :         value_type* _Result = _Bx._Buf;

	mov	eax, ebx

; 2153 :         return _BUF_SIZE <= _Myres;

	cmp	esi, 16					; 00000010H

; 2136 :         if (_Large_string_engaged()) {

	jb	SHORT $LN9@append

; 2137 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [ebx]
$LN9@append:

; 363  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	push	edi

; 2863 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	lea	esi, DWORD PTR [eax+ecx]

; 363  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	push	edx
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 2864 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [esi+edi], 0

; 2880 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	eax, ebx
	pop	edi

; 2881 :     }

	pop	esi
	pop	ebx
	pop	ebp
	ret	4
$LN6@append:

; 2868 :         return _Reallocate_grow_by(

	push	edi
	push	edx
	mov	BYTE PTR $T5[ebp], 0
	mov	ecx, ebx
	push	DWORD PTR $T5[ebp]
	push	edi
	call	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
	pop	edi

; 2881 :     }

	pop	esi
	pop	ebx
	pop	ebp
	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z
_TEXT	SEGMENT
$T5 = -4						; size = 1
__Ptr$dead$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 2822 :     basic_string& operator+=(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	push	edi
	mov	edi, ecx

; 2860 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	edx, DWORD PTR [edi+20]
	mov	eax, edx
	mov	ecx, DWORD PTR [edi+16]
	sub	eax, ecx
	cmp	eax, 6
	jb	SHORT $LN8@operator

; 2861 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [ecx+6]
	mov	DWORD PTR [edi+16], eax

; 2135 :         value_type* _Result = _Bx._Buf;

	mov	eax, edi

; 2153 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 2136 :         if (_Large_string_engaged()) {

	jb	SHORT $LN11@operator

; 2137 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [edi]
$LN11@operator:
	push	esi

; 363  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	push	6

; 2863 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	lea	esi, DWORD PTR [eax+ecx]

; 363  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	push	OFFSET ??_C@_06IKCLLJCF@?5tank?$CB@
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 2864 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [esi+6], 0

; 2823 :         return append(_Ptr);

	mov	eax, edi
	pop	esi
	pop	edi

; 2824 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN8@operator:

; 2868 :         return _Reallocate_grow_by(

	push	6
	push	OFFSET ??_C@_06IKCLLJCF@?5tank?$CB@
	mov	BYTE PTR $T5[ebp], 0
	mov	ecx, edi
	push	DWORD PTR $T5[ebp]
	push	6
	call	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
	pop	edi

; 2824 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2418 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

	push	ebp
	mov	ebp, esp

; 2606 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	eax, DWORD PTR __Right$[ebp]

; 2124 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0

; 2606 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 4293 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [eax], 0

; 2419 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2420 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2421 :     }

	mov	eax, ecx
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2317 :         : _Mypair(_Zero_then_variadic_args_t{}) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 2318 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2319 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2320 :         _Tidy_init();
; 2321 :         assign(_Ptr, _Count);

	push	5
	push	OFFSET ??_C@_05DGFDNKII@Rabit@

; 4293 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [esi], 0

; 2318 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2319 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2320 :         _Tidy_init();
; 2321 :         assign(_Ptr, _Count);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2322 :         _Proxy._Release();
; 2323 :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 4329 :         return _Mypair._Get_first();

	mov	eax, ecx

; 4330 :     }

	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4293 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0

; 4297 :     }

	ret	0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
$T3 = 12						; size = 1
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2857 :     basic_string& append(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

	push	ebp
	mov	ebp, esp
	push	ebx

; 2858 :         // append [_Ptr, _Ptr + _Count)
; 2859 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 2860 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	ebx, DWORD PTR __Count$[ebp]
	push	edi
	mov	edi, ecx
	mov	edx, DWORD PTR [edi+20]
	mov	eax, edx
	mov	ecx, DWORD PTR [edi+16]
	sub	eax, ecx
	cmp	ebx, eax
	ja	SHORT $LN2@append

; 2861 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [ecx+ebx]
	mov	DWORD PTR [edi+16], eax

; 2135 :         value_type* _Result = _Bx._Buf;

	mov	eax, edi

; 2153 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 2136 :         if (_Large_string_engaged()) {

	jb	SHORT $LN5@append

; 2137 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [edi]
$LN5@append:
	push	esi

; 363  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	push	ebx
	push	DWORD PTR __Ptr$[ebp]

; 2862 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 2863 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	lea	esi, DWORD PTR [eax+ecx]

; 363  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 2864 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [esi+ebx], 0

; 2865 :             return *this;

	mov	eax, edi
	pop	esi
	pop	edi

; 2869 :             _Count,
; 2870 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 2871 :                 const size_type _Count) {
; 2872 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2873 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2874 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2875 :             },
; 2876 :             _Ptr, _Count);
; 2877 :     }

	pop	ebx
	pop	ebp
	ret	8
$LN2@append:

; 2866 :         }
; 2867 : 
; 2868 :         return _Reallocate_grow_by(

	push	ebx
	push	DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR $T3[ebp], 0
	mov	ecx, edi
	push	DWORD PTR $T3[ebp]
	push	ebx
	call	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
	pop	edi

; 2869 :             _Count,
; 2870 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 2871 :                 const size_type _Count) {
; 2872 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2873 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2874 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2875 :             },
; 2876 :             _Ptr, _Count);
; 2877 :     }

	pop	ebx
	pop	ebp
	ret	8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ptr$ = 20						; size = 4
__Count$ = 24						; size = 4
??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z PROC ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator(), COMDAT
; _this$dead$ = ecx

; 2871 :                 const size_type _Count) {

	push	ebp
	mov	ebp, esp
	push	esi

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	esi, DWORD PTR __New_ptr$[ebp]

; 2871 :                 const size_type _Count) {

	push	edi

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	edi, DWORD PTR __Old_size$[ebp]
	push	edi
	push	DWORD PTR __Old_ptr$[ebp]
	push	esi
	call	_memcpy

; 2872 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2873 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

	add	edi, esi

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	esi, DWORD PTR __Count$[ebp]
	push	esi
	push	DWORD PTR __Ptr$[ebp]
	push	edi
	call	_memcpy
	add	esp, 24					; 00000018H

; 2874 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [edi+esi], 0
	pop	edi
	pop	esi

; 2875 :             },

	pop	ebp
	ret	20					; 00000014H
??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z ENDP ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents, COMDAT
; _this$ = ecx

; 2609 :     void _Take_contents(basic_string& _Right, true_type) noexcept {

	push	ebp
	mov	ebp, esp

; 2606 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	eax, DWORD PTR __Right$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 4293 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [eax], 0

; 2610 :         // assign by stealing _Right's buffer, memcpy optimization
; 2611 :         // pre: this != &_Right
; 2612 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2613 :         // pre: *this owns no memory, iterators orphaned (note:
; 2614 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2615 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2616 :         if (_Right._Mypair._Myval2._Large_string_engaged()) {
; 2617 :             // take ownership of _Right's iterators along with its buffer
; 2618 :             _Swap_proxy_and_iterators(_Right);
; 2619 :         } else {
; 2620 :             _Right._Mypair._Myval2._Orphan_all();
; 2621 :         }
; 2622 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2623 : 
; 2624 :         _Memcpy_val_from(_Right);
; 2625 :         _Right._Tidy_init();
; 2626 :     }

	pop	ebp
	ret	8
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1348 :         return *this;

	mov	eax, ecx

; 1349 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$dead$ = ecx

; 3690 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());
; 3691 :         const size_type _Storage_max = // can always store small string
; 3692 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 3693 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

	mov	eax, 2147483647				; 7fffffffH

; 3694 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3695 :         );
; 3696 :     }

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from, COMDAT
; _this$ = ecx

; 2600 :     void _Memcpy_val_from(const basic_string& _Right) noexcept {

	push	ebp
	mov	ebp, esp

; 2601 :         _STL_INTERNAL_CHECK(_Can_memcpy_val); // TRANSITION, if constexpr
; 2602 :         const auto _My_data_mem =
; 2603 :             reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 2604 :         const auto _Right_data_mem =
; 2605 :             reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 2606 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	eax, DWORD PTR __Right$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 2607 :     }

	pop	ebp
	ret	4
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2153 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2135 :         value_type* _Result = _Bx._Buf;
; 2136 :         if (_Large_string_engaged()) {

	jb	SHORT $LN6@Myptr

; 2137 :             _Result = _Unfancy(_Bx._Ptr);
; 2138 :         }
; 2139 : 
; 2140 :         return _Result;

	mov	eax, DWORD PTR [ecx]

; 2141 :     }

	ret	0
$LN6@Myptr:

; 2137 :             _Result = _Unfancy(_Bx._Ptr);
; 2138 :         }
; 2139 : 
; 2140 :         return _Result;

	mov	eax, ecx

; 2141 :     }

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z
_TEXT	SEGMENT
$T6 = -4						; size = 1
___$ReturnUdt$ = -4					; size = 4
__Right$dead$ = 8					; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$ = edx

; 4457 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, _In_z_ const _Elem* const _Right) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 2860 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	ecx, edx

; 4457 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, _In_z_ const _Elem* const _Right) {

	mov	DWORD PTR ___$ReturnUdt$[ebp], esi

; 2860 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	eax, DWORD PTR [edx+20]

; 4457 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, _In_z_ const _Elem* const _Right) {

	push	edi

; 2859 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	edi, DWORD PTR [edx+16]

; 2860 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	sub	eax, edi
	cmp	eax, 4
	jb	SHORT $LN10@operator

; 2153 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [edx+20], 16			; 00000010H

; 2861 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [edx+16], eax

; 2136 :         if (_Large_string_engaged()) {

	jb	SHORT $LN13@operator

; 2137 :             _Result = _Unfancy(_Bx._Ptr);

	mov	ecx, DWORD PTR [edx]
$LN13@operator:

; 363  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	mov	eax, DWORD PTR ??_C@_04HCFFIKMN@tank@
	mov	DWORD PTR [ecx+edi], eax

; 2864 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [ecx+edi+4], 0

; 2865 :             return *this;

	jmp	SHORT $LN9@operator
$LN10@operator:

; 2866 :         }
; 2867 : 
; 2868 :         return _Reallocate_grow_by(

	push	4
	push	OFFSET ??_C@_04HCFFIKMN@tank@
	mov	BYTE PTR $T6[ebp], 0
	push	DWORD PTR $T6[ebp]
	push	4
	call	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
	mov	edx, eax
$LN9@operator:

; 2124 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	mov	DWORD PTR [esi+16], 0

; 4458 :     return _STD move(_Left.append(_Right));

	mov	eax, esi

; 2124 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	mov	DWORD PTR [esi+20], 0

; 2606 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [edx]

; 4458 :     return _STD move(_Left.append(_Right));

	pop	edi

; 2606 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	XMMWORD PTR [esi], xmm0
	movq	xmm0, QWORD PTR [edx+16]
	movq	QWORD PTR [esi+16], xmm0

; 4293 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [edx+16], 0

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [edx+20], 15			; 0000000fH

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [edx], 0

; 4458 :     return _STD move(_Left.append(_Right));

	pop	esi

; 4459 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT
; __Arg$ = ecx

; 1467 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1468 : }

	ret	0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::move<std::allocator<char> &>, COMDAT
; __Arg$ = ecx

; 1467 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1468 : }

	ret	0
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::move<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2124 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	mov	DWORD PTR [ecx+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1341 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 2124 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	mov	DWORD PTR [ecx+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 1341 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	8
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__Old$1$ = -8						; size = 4
_<_Args_0>$GSCopy$1$ = -4				; size = 4
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 4218 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	ebx
	mov	DWORD PTR _<_Args_0>$GSCopy$1$[ebp], eax
	mov	ebx, ecx

; 4219 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4220 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4221 :         if (_New_size > max_size()) {

	mov	eax, DWORD PTR __New_size$[ebp]
	push	edi
	cmp	eax, 2147483647				; 7fffffffH
	ja	$LN61@Reallocate

; 4223 :         }
; 4224 : 
; 4225 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

	mov	ecx, DWORD PTR [ebx+20]
	push	esi

; 4201 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	esi, eax

; 4223 :         }
; 4224 : 
; 4225 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

	mov	DWORD PTR __Old$1$[ebp], ecx

; 4201 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	esi, 15					; 0000000fH
	cmp	esi, 2147483647				; 7fffffffH

; 4202 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN9@Reallocate

; 4203 :             return _Max;

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN8@Reallocate
$LN9@Reallocate:

; 4204 :         }
; 4205 : 
; 4206 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	edx, ecx
	mov	eax, 2147483647				; 7fffffffH
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN10@Reallocate

; 4207 :             return _Max;

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN8@Reallocate
$LN10@Reallocate:

; 4208 :         }
; 4209 : 
; 4210 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

	cmp	esi, eax
	cmovb	esi, eax
$LN8@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4228 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	xor	ecx, ecx
	mov	eax, esi
	add	eax, 1
	setb	cl
	neg	ecx
	or	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN17@Reallocate

; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 116  :     if (_Block_size <= _Bytes) {

	cmp	eax, ecx
	jbe	$LN62@Reallocate

; 77   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	SHORT $LN53@Reallocate

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	edi, DWORD PTR [eax+35]
	and	edi, -32				; ffffffe0H

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [edi-4], eax

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN16@Reallocate
$LN17@Reallocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

	test	ecx, ecx
	je	SHORT $LN18@Reallocate

; 77   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 206  :         return _Traits::_Allocate(_Bytes);

	mov	edi, eax
	jmp	SHORT $LN16@Reallocate
$LN18@Reallocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

	xor	edi, edi
$LN16@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4230 :         _Mypair._Myval2._Mysize = _New_size;

	mov	eax, DWORD PTR __New_size$[ebp]

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	push	DWORD PTR _<_Args_0>$GSCopy$1$[ebp]

; 4230 :         _Mypair._Myval2._Mysize = _New_size;

	mov	DWORD PTR [ebx+16], eax

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	push	edi

; 4231 :         _Mypair._Myval2._Myres  = _New_capacity;

	mov	DWORD PTR [ebx+20], esi

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	call	_memcpy

; 2978 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	eax, DWORD PTR __New_size$[ebp]

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 12					; 0000000cH

; 4232 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
; 4233 :         if (_BUF_SIZE <= _Old_capacity) {

	mov	ecx, DWORD PTR __Old$1$[ebp]

; 2978 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	BYTE PTR [edi+eax], 0

; 4232 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
; 4233 :         if (_BUF_SIZE <= _Old_capacity) {

	pop	esi
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN3@Reallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4234 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

	inc	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN56@Reallocate

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN53@Reallocate

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN56@Reallocate:

; 221  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN3@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4240 :         return *this;

	mov	DWORD PTR [ebx], edi
	mov	eax, ebx
	pop	edi
	pop	ebx

; 4241 :     }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN53@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN61@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4222 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
$LN62@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 117  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN59@Reallocate:
	int	3
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z
_TEXT	SEGMENT
_<_Args_0>$GSCopy$1$ = -16				; size = 4
__Old$1$ = -12						; size = 4
__Old_size$1$ = -8					; size = 4
tv466 = -4						; size = 4
__New_size$1$ = -4					; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>, COMDAT
; _this$ = ecx

; 4244 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	ebx
	mov	ebx, ecx
	mov	DWORD PTR _<_Args_0>$GSCopy$1$[ebp], eax

; 4245 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4246 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4247 :         auto& _My_data            = _Mypair._Myval2;
; 4248 :         const size_type _Old_size = _My_data._Mysize;
; 4249 :         if (max_size() - _Old_size < _Size_increase) {

	mov	ecx, 2147483647				; 7fffffffH
	mov	eax, ecx
	push	esi
	mov	edx, DWORD PTR [ebx+16]
	sub	eax, edx
	mov	esi, DWORD PTR __Size_increase$[ebp]
	mov	DWORD PTR __Old_size$1$[ebp], edx
	push	edi
	cmp	eax, esi
	jb	$LN69@Reallocate

; 4254 :         const size_type _Old_capacity = _My_data._Myres;

	mov	edi, DWORD PTR [ebx+20]
	lea	eax, DWORD PTR [edx+esi]

; 4201 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	esi, eax

; 4251 :         }
; 4252 : 
; 4253 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	DWORD PTR __New_size$1$[ebp], eax

; 4201 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	esi, 15					; 0000000fH

; 4254 :         const size_type _Old_capacity = _My_data._Myres;

	mov	DWORD PTR __Old$1$[ebp], edi

; 4201 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	esi, ecx

; 4202 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN9@Reallocate

; 4203 :             return _Max;

	mov	esi, ecx
	jmp	SHORT $LN8@Reallocate
$LN9@Reallocate:

; 4204 :         }
; 4205 : 
; 4206 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	eax, edi
	shr	eax, 1
	sub	ecx, eax
	cmp	edi, ecx
	jbe	SHORT $LN10@Reallocate

; 4207 :             return _Max;

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN8@Reallocate
$LN10@Reallocate:

; 4208 :         }
; 4209 : 
; 4210 :         return (_STD max)(_Masked, _Old + _Old / 2);

	add	eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

	cmp	esi, eax
	cmovb	esi, eax
$LN8@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4257 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	xor	ecx, ecx
	mov	eax, esi
	add	eax, 1
	setb	cl
	neg	ecx
	or	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN17@Reallocate

; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 116  :     if (_Block_size <= _Bytes) {

	cmp	eax, ecx
	jbe	$LN70@Reallocate

; 77   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	$LN55@Reallocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	edx, DWORD PTR __Old_size$1$[ebp]

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	edi, DWORD PTR [eax+35]
	and	edi, -32				; ffffffe0H

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [edi-4], eax

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN16@Reallocate
$LN17@Reallocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

	test	ecx, ecx
	je	SHORT $LN18@Reallocate

; 77   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new

; 206  :         return _Traits::_Allocate(_Bytes);

	mov	edx, DWORD PTR __Old_size$1$[ebp]

; 77   :         return ::operator new(_Bytes);

	add	esp, 4

; 206  :         return _Traits::_Allocate(_Bytes);

	mov	edi, eax
	jmp	SHORT $LN16@Reallocate
$LN18@Reallocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

	xor	edi, edi
$LN16@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4259 :         _My_data._Mysize      = _New_size;

	mov	eax, DWORD PTR __New_size$1$[ebp]
	mov	DWORD PTR [ebx+16], eax

; 4260 :         _My_data._Myres       = _New_capacity;
; 4261 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	mov	eax, DWORD PTR _<_Args_1>$[ebp]
	mov	DWORD PTR [ebx+20], esi
	lea	esi, DWORD PTR [edi+edx]
	add	eax, esi

; 4262 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	DWORD PTR __Old$1$[ebp], 16		; 00000010H
	mov	DWORD PTR tv466[ebp], eax
	push	edx
	jb	SHORT $LN3@Reallocate

; 4263 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	esi, DWORD PTR [ebx]

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	push	esi
	push	edi
	call	_memcpy
	push	DWORD PTR _<_Args_1>$[ebp]
	mov	eax, DWORD PTR __Old_size$1$[ebp]
	push	DWORD PTR _<_Args_0>$GSCopy$1$[ebp]
	add	eax, edi
	push	eax
	call	_memcpy

; 2874 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	eax, DWORD PTR tv466[ebp]

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 24					; 00000018H

; 4264 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4265 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	ecx, DWORD PTR __Old$1$[ebp]
	inc	ecx

; 2874 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN58@Reallocate

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [esi-4]
	add	ecx, 35					; 00000023H

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	esi, edx

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [esi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN55@Reallocate

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	esi, edx
$LN58@Reallocate:

; 221  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4272 :         return *this;

	mov	DWORD PTR [ebx], edi
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx

; 4273 :     }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN55@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN3@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	push	ebx
	push	edi
	call	_memcpy
	push	DWORD PTR _<_Args_1>$[ebp]
	push	DWORD PTR _<_Args_0>$GSCopy$1$[ebp]
	push	esi
	call	_memcpy

; 2874 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	eax, DWORD PTR tv466[ebp]

; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 24					; 00000018H

; 2874 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [eax], 0

; 4272 :         return *this;

	mov	eax, ebx
	mov	DWORD PTR [ebx], edi
	pop	edi
	pop	esi
	pop	ebx

; 4273 :     }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN69@Reallocate:

; 4250 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
$LN70@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory

; 117  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN67@Reallocate:
	int	3
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))
; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

	ret	0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 276  : }

	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z
_TEXT	SEGMENT
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > const >, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 276  : }

	ret	0
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4213 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

	push	ebp
	mov	ebp, esp

; 4201 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	edx, DWORD PTR __Requested$[ebp]

; 4202 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	mov	eax, 2147483647				; 7fffffffH
	or	edx, 15					; 0000000fH

; 4213 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

	push	esi

; 4214 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	esi, DWORD PTR [ecx+20]

; 4201 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	edx, eax

; 4202 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN3@Calculate_

; 4203 :             return _Max;
; 4204 :         }
; 4205 : 
; 4206 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	ecx, esi
	shr	ecx, 1
	sub	eax, ecx
	cmp	esi, eax
	jbe	SHORT $LN5@Calculate_

; 4214 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	eax, 2147483647				; 7fffffffH
	pop	esi

; 4215 :     }

	pop	ebp
	ret	4
$LN5@Calculate_:

; 4210 :         return (_STD max)(_Masked, _Old + _Old / 2);

	add	ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

	cmp	edx, ecx
	cmovb	edx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring

; 4214 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	eax, edx
$LN3@Calculate_:
	pop	esi

; 4215 :     }

	pop	ebp
	ret	4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1456 : }

	ret	0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 276  : }

	ret	0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
END
